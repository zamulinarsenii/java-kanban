package task;

import manager.InMemoryTaskManager;
import manager.Managers;
import manager.TaskManager;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.*;

class TaskTest {
    private TaskManager taskManager;
    private Task task1;
    private Task task2;
    private Epic epic1;
    private Subtask subtask1;

    @BeforeEach
    void setUp() {
        taskManager = new InMemoryTaskManager();
        task1 = new Task("Task 1", "Description 1", 1);
        task2 = new Task("Task 2", "Description 2", 1); // Совпадает id с task1
        epic1 = new Epic("Epic 1", "Epic Description", 2);
        subtask1 = new Subtask("Subtask 1", "Sub Description", 3, Status.NEW, 2);
    }

    // 1. Проверка равенства Task по id
    @Test
    void tasksWithSameIdShouldBeEqual() {
        assertEquals(task1, task2, "Задачи с одинаковым id должны быть равны");
    }

    // 2. Проверка равенства наследников Task по id
    @Test
    void epicsWithSameIdShouldBeEqual() {
        Epic epic2 = new Epic("Epic 2", "Another Description", 2);
        assertEquals(epic1, epic2, "Эпики с одинаковым id должны быть равны");
    }

    // 3. Epic не может быть подзадачей сам себе
    @Test
    void epicCannotBeSubtaskToItself() {
        Subtask invalidSubtask = new Subtask("Invalid", "Desc", 4, Status.NEW, epic1.getId());
        taskManager.addEpic(epic1);
        taskManager.addSubtask(invalidSubtask);

        assertFalse(epic1.getSubtasksId().contains(epic1.getId()), "Эпик не должен содержать себя как подзадачу");
    }

    // 4. Subtask не может быть своим эпиком
    @Test
    void subtaskCannotBeItsOwnEpic() {
        Subtask invalidSubtask = new Subtask("Invalid", "Desc", 5, Status.NEW, 5); // epicId = собственному id
        taskManager.addSubtask(invalidSubtask);

        assertNull(taskManager.getById(5), "Подзадача с epicId = собственному id не должна добавляться");
    }

    // 5. Утилитарный класс возвращает готовые менеджеры
    @Test
    void managersShouldBeInitialized() {
        Managers managers = new Managers();
        assertNotNull(managers.getDefault(), "Менеджер должен быть проинициализирован");
        assertNotNull(managers.getDefaultHistory(), "История должна быть проинициализирована");
    }

    // 6. Добавление и поиск задач по id
    @Test
    void managerShouldAddAndFindTasks() {
        taskManager.addTask(task1);
        taskManager.addEpic(epic1);
        taskManager.addSubtask(subtask1);

        assertEquals(task1, taskManager.getById(1));
        assertEquals(epic1, taskManager.getById(2));
        assertEquals(subtask1, taskManager.getById(3));

    }

    // 7. Неконфликтующие id
    @Test
    void manualAndAutoGeneratedIdsShouldNotConflict() {
        Task manualTask = new Task("Manual", "Desc", 100);
        taskManager.addTask(manualTask);
        taskManager.addTask(new Task("Auto", "Desc", 1));

        assertNotEquals(manualTask.getId(), taskManager.getById(1).getId(), "ID не должны конфликтовать");
    }


    // 8. История сохраняет предыдущие версии
    @Test
    void historyShouldKeepTaskVersions() {
        Task task = new Task("Task", "Desc", 20);
        taskManager.addTask(task);
        taskManager.getById(20); // Добавляем в историю
        task.setStatus(Status.DONE);
        taskManager.updateTask(task);

        assertEquals(Status.NEW, taskManager.getHistory().get(0).getStatus(), "История должна хранить предыдущее состояние");
    }
}